<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.2"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>generic_iterators: The Typeclass Pattern</title>

<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>

<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>

<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>

<link href="doxygen.css" rel="stylesheet" type="text/css" />

</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->


<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  
  
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">generic_iterators
   &#160;<span id="projectnumber">1.0.0</span>
   </div>
   <div id="projectbrief">Demonstration of implementing and using type safe generic iterators in pure, standard C</div>
  </td>
  
  
  
 </tr>
 </tbody>
</table>
</div>

<!-- end header part -->
<!-- Generated by Doxygen 1.9.2 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('md_Typeclass_Pattern.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div><div class="header">
  <div class="headertitle">
<div class="title">The Typeclass Pattern </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p class="">This document aims to describe the typeclass (or trait, or interface) based polymorphism pattern used in this demonstration.</p>
<p class=""><b>Note</b>: The information in this document is outdated. An extended version of this document can be found at <a href="https://github.com/TotallyNotChase/typeclass-interface-pattern">typeclass-interface-pattern</a>.</p>
<h1>Goals</h1>
<p class="">Alongside describing the core parts of this pattern, this document will also describe how to <b>combine multiple typeclass constraints into one constraint</b>. As in, how you can have a type that is required to implement multiple typeclasses.</p>
<h1>Brief</h1>
<p class="">Function pointer based polymorphism isn't new to C by any means. The major difference in the typeclass pattern, and the typical vtable based approach is simply that typeclasses are based around actions, rather than objects. This is very similar to an interface in OOP terms.</p>
<h1>Core parts</h1>
<p class="">There are 3 core parts to this pattern. These parts will be demonstrated by implementing the <a href="https://hackage.haskell.org/package/base-4.15.0.0/docs/Text-Show.html#t:Show"><code>Show</code></a> typeclass.</p>
<h2>The <code>typeclass</code> struct definition</h2>
<p class="">This is the struct containing the function pointers related to the typeclass. For <code>Show</code>, we'll just be using the <code>show</code> function here, it takes in a value of the type for which <code>Show</code> is implemented (i.e <code>self</code>) and returns a printable string. </p><div class="fragment"><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span></div>
<div class="line">{</div>
<div class="line">    <span class="keywordtype">char</span>* (*<span class="keyword">const</span> show)(<span class="keywordtype">void</span>* <span class="keyword">self</span>);</div>
<div class="line">} Show;</div>
</div><!-- fragment --><p> This can be simplified using the <a href="https://totallynotchase.github.io/c-iterators/typeclass_8h.html#ab36f9f0d3603452a867a683078618034"><code>typeclass</code></a> macro provided in <a href="./typeclass.h">typeclass.h</a>. </p><div class="fragment"><div class="line"><span class="keyword">typedef</span> <a class="code" href="typeclass_8h.html#ab36f9f0d3603452a867a683078618034">typeclass</a>(<span class="keywordtype">char</span>* (*<span class="keyword">const</span> show)(<span class="keywordtype">void</span>* <span class="keyword">self</span>)) Show;</div>
<div class="ttc" id="atypeclass_8h_html_ab36f9f0d3603452a867a683078618034"><div class="ttname"><a href="typeclass_8h.html#ab36f9f0d3603452a867a683078618034">typeclass</a></div><div class="ttdeci">#define typeclass(funcs)</div><div class="ttdoc">Define a typeclass with the given functions.</div><div class="ttdef"><b>Definition:</b> typeclass.h:23</div></div>
</div><!-- fragment --><p class="">A simple struct containing the virtual function(s). When the wrapper function is first called (to convert a certain type to its typeclass instance), a typeclass struct of <code>static</code> storage duration is created with the function pointers for that specific type (a vtable of sorts). The pointer to this struct is then used in all typeclass instances. More on this will be discussed in the <code>impl_</code> macro part.</p>
<h2>The <code>typeclass_instance</code> struct definition</h2>
<p class="">This is the concrete instance to be used as a type constraint. It should contain a pointer to the typeclass, and the <code>self</code> member containing the value to pass to the functions in the typeclass struct. </p><div class="fragment"><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span></div>
<div class="line">{</div>
<div class="line">    <span class="keywordtype">void</span>* <span class="keyword">self</span>;</div>
<div class="line">    Show <span class="keyword">const</span>* tc;</div>
<div class="line">} Showable;</div>
</div><!-- fragment --><p> This can also be simplified using the <a href="https://totallynotchase.github.io/c-iterators/typeclass_8h.html#af018200b2431a3ab6c296cc8940ecbe3"><code>typeclass_instance</code></a> macro provided in <a href="./typeclass.h">typeclass.h</a>. </p><div class="fragment"><div class="line"><span class="keyword">typedef</span> <a class="code" href="typeclass_8h.html#af018200b2431a3ab6c296cc8940ecbe3">typeclass_instance</a>(Show) Showable;</div>
<div class="ttc" id="atypeclass_8h_html_af018200b2431a3ab6c296cc8940ecbe3"><div class="ttname"><a href="typeclass_8h.html#af018200b2431a3ab6c296cc8940ecbe3">typeclass_instance</a></div><div class="ttdeci">#define typeclass_instance(Typeclass)</div><div class="ttdoc">Define a typeclass instance for the given typeclass.</div><div class="ttdef"><b>Definition:</b> typeclass.h:43</div></div>
</div><!-- fragment --><h2>The <code>impl_</code> macro used to implement the typeclass</h2>
<p class="">This macro is the real heavy lifter when it comes to type safety.</p>
<p class="">It takes in some information about the type you're implementing a typeclass for, and the exact function implementations that will be used for that type, and defines a function which does the following-</p><ul>
<li>Takes in an argument of the type the implementation is for.</li>
<li><p class="startli">Type checks the function implementations given.</p>
<p class="startli">This is done by storing the given function implementations into function pointers of an exact and expected type.</p>
</li>
<li>Initializes the typeclass struct to store these function pointers, with static storage duration.</li>
<li>Creates and returns the typeclass instance, which stores a pointer to the aforementioned typeclass struct, and the function argument into the <code>self</code> member.</li>
</ul>
<p class="">Following these rules, this is what <code>impl_show</code> would look like- </p><div class="fragment"><div class="line"><span class="preprocessor">#define impl_show(T, Name, show_f)                                                                                     \</span></div>
<div class="line"><span class="preprocessor">    Showable Name(T x)                                                                                                 \</span></div>
<div class="line"><span class="preprocessor">    {                                                                                                                  \</span></div>
<div class="line"><span class="preprocessor">        char* (*const show_)(T e) = (show_f);                                                                          \</span></div>
<div class="line"><span class="preprocessor">        (void)show_;                                                                                                   \</span></div>
<div class="line"><span class="preprocessor">        static Show const tc = {.show = (char* (*const)(void*))(show_f) };                                             \</span></div>
<div class="line"><span class="preprocessor">        return (Showable){.tc = &amp;tc, .self = x};                                                                       \</span></div>
<div class="line"><span class="preprocessor">    }</span></div>
</div><!-- fragment --><p> It takes the <code>show</code> implementation as its third argument. In the function definition, it stores that impl in a variable of type <code>char* (*const show_)(T e)</code>, which is the exact type it should be - <code>T</code> is the specific type the implementation is for. It <b>must be a pointer type</b>. Since it's stored into <code>void* self</code>.</p>
<p class="">The <code>(void)show_;</code> line is to suppress the unused variable warning emitted by compilers, since <code>show_</code> isn't actually used. It's only there for typechecking purposes. These 2 typechecking lines will be completely eliminated by any decent compiler.</p>
<p class="">Then it simply defines a static typeclass and stores the function pointer inside. Then it creates and returns the <code>Showable</code> struct, containing the <code>x</code> argument, and a pointer to the typeclass struct.</p>
<h1>Usage</h1>
<p class="">Once the typeclass and typeclass instance structs have been defined, all the user has to do is call the <code>impl_</code> macro with their own type and the function implementation(s) required for the typeclass. The declaration of the function defined by said macro can then be included in a header. After that, that function can be used to turn the concrete type into its typeclass instance.</p>
<p class="">Here's an example of implementing the previously defined <code>Show</code> typeclass for an enum- </p><div class="fragment"><div class="line"><span class="keyword">typedef</span> <span class="keyword">enum</span></div>
<div class="line">{</div>
<div class="line">    holy,</div>
<div class="line">    hand,</div>
<div class="line">    grenade</div>
<div class="line">} Antioch;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">char</span>* strdup_(<span class="keywordtype">char</span> <span class="keyword">const</span>* x)</div>
<div class="line">{</div>
<div class="line">    <span class="keywordtype">char</span>* s = malloc((strlen(x) + 1) * <span class="keyword">sizeof</span>(*s));</div>
<div class="line">    strcpy(s, x);</div>
<div class="line">    <span class="keywordflow">return</span> s;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">/* The `show` function implementation for `Antioch*` */</span></div>
<div class="line"><span class="keyword">static</span> <span class="keywordtype">char</span>* antioch_show(Antioch* x)</div>
<div class="line">{</div>
<div class="line">    <span class="comment">/*</span></div>
<div class="line"><span class="comment">    Note: The `show` function of a `Showable` is expected to return a malloc&#39;ed value</span></div>
<div class="line"><span class="comment">    The users of a generic `Showable` are expected to `free` the returned pointer from the function `show`.</span></div>
<div class="line"><span class="comment">    */</span></div>
<div class="line">    <span class="keywordflow">switch</span> (*x)</div>
<div class="line">    {</div>
<div class="line">        <span class="keywordflow">case</span> holy:</div>
<div class="line">            <span class="keywordflow">return</span> strdup_(<span class="stringliteral">&quot;holy&quot;</span>);</div>
<div class="line">        <span class="keywordflow">case</span> hand:</div>
<div class="line">            <span class="keywordflow">return</span> strdup_(<span class="stringliteral">&quot;hand&quot;</span>);</div>
<div class="line">        <span class="keywordflow">case</span> grenade:</div>
<div class="line">            <span class="keywordflow">return</span> strdup_(<span class="stringliteral">&quot;grenade&quot;</span>);</div>
<div class="line">        <span class="keywordflow">default</span>:</div>
<div class="line">            <span class="keywordflow">return</span> strdup_(<span class="stringliteral">&quot;breakfast cereal&quot;</span>);</div>
<div class="line">    }</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">/*</span></div>
<div class="line"><span class="comment">Implement the `Show` typeclass for the type `Antioch*`</span></div>
<div class="line"><span class="comment"></span> </div>
<div class="line"><span class="comment">This will define a function to convert a value of type `Antioch*` into a `Showable`, the function will be named `prep_antioch_show`</span></div>
<div class="line"><span class="comment"></span> </div>
<div class="line"><span class="comment">The `show` implementation used will be the `antioch_show` function</span></div>
<div class="line"><span class="comment">*/</span></div>
<div class="line">impl_show(Antioch*, prep_antioch_show, antioch_show)</div>
</div><!-- fragment --><p> The <code>impl_show</code> macro here, simply translates to- </p><div class="fragment"><div class="line">Showable prep_antioch_show(Antioch* x)</div>
<div class="line">{</div>
<div class="line">    <span class="keywordtype">char</span>* (*<span class="keyword">const</span> show_)(Antioch* e) = (show_f);</div>
<div class="line">    (void)show_;</div>
<div class="line">    <span class="keyword">static</span> Show <span class="keyword">const</span> tc = {.show = (<span class="keywordtype">char</span>* (*const)(<span class="keywordtype">void</span>*)(show_f) };</div>
<div class="line">    <span class="keywordflow">return</span> (Showable){.tc = &amp;tc, .self = x};</div>
<div class="line">}</div>
</div><!-- fragment --><p class="">Now, you can convert an <code>Antioch</code> into a <code>Showable</code> like so- </p><div class="fragment"><div class="line">Antioch ant = holy;</div>
<div class="line">Showable antsh = prep_antioch_show(&amp;ant);</div>
</div><!-- fragment --><p> And this <code>Showable</code> will automatically dispatch to the <code>antioch_show</code> function whenever someone calls the <code>show</code> function inside it.</p>
<p class="">Now you can make polymorphic functions that works on <code>Showable</code>s. Here's one of them- </p><div class="fragment"><div class="line"><span class="keywordtype">void</span> print(Showable showable)</div>
<div class="line">{</div>
<div class="line">    <span class="keywordtype">char</span>* s = showable.tc-&gt;show(showable.self);</div>
<div class="line">    puts(s);</div>
<div class="line">    free(s);</div>
<div class="line">}</div>
</div><!-- fragment --><p> You can now easily print an <code>Antioch</code> with these abstractions- </p><div class="fragment"><div class="line">Antioch ant = holy;</div>
<div class="line">print(prep_antioch_show(&amp;ant));</div>
</div><!-- fragment --><p> Where this really shines though, is when you have multiple types that implement <code>Show</code> - all of them can be used with <code>print</code>. Or any other function that works on a generic <code>Showable</code>!</p>
<h1>Combining multiple typeclasses</h1>
<p class="">One of the core design goals of a typeclass is to be modular. A <code>Show</code> typeclass should only have actions directly related to "showing", a <code>Num</code> typeclass should only have actions directly related to numerical operations. Unlike objects, that may contain many different methods of arbitrary relevance to each other.</p>
<p class="">This means that, more often than not, you'll want a type that can do multiple different classes of actions. A type that implements multiple typeclasses.</p>
<p class="">You can model that pretty easily with this pattern- </p><div class="fragment"><div class="line"><span class="comment">/* Type constraint that requires both `Show` and `Enum` to be implemented */</span></div>
<div class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span></div>
<div class="line">{</div>
<div class="line">    <span class="keywordtype">void</span>* <span class="keyword">self</span>;</div>
<div class="line">    Show <span class="keyword">const</span>* showtc;</div>
<div class="line">    Enum <span class="keyword">const</span>* enumtc;</div>
<div class="line">} ShowableEnumerable;</div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#define impl_show_enum(T, Name, showimpl, enumimpl)                                                                    \</span></div>
<div class="line"><span class="preprocessor">    ShowableEnumerable Name(T x)                                                                                       \</span></div>
<div class="line"><span class="preprocessor">    {                                                                                                                  \</span></div>
<div class="line"><span class="preprocessor">        Showable showable = showimpl(x);                                                                               \</span></div>
<div class="line"><span class="preprocessor">        Enumerable enumerable = enumimpl(x);                                                                           \</span></div>
<div class="line"><span class="preprocessor">        return (ShowableEnumerable){.showtc = showable.tc, .enumtc = enumerable.tc, .self = x};                        \</span></div>
<div class="line"><span class="preprocessor">    }</span></div>
</div><!-- fragment --><p class="">Where <a href="https://hackage.haskell.org/package/base-4.15.0.0/docs/Prelude.html#t:Enum"><code>Enum</code></a> is also a typeclass defined like- </p><div class="fragment"><div class="line"><span class="keyword">typedef</span> <a class="code" href="typeclass_8h.html#ab36f9f0d3603452a867a683078618034">typeclass</a>(</div>
<div class="line">    <span class="keywordtype">size_t</span> (*<span class="keyword">const</span> from_enum)(<span class="keywordtype">void</span>* <span class="keyword">self</span>);</div>
<div class="line">    <span class="keywordtype">void</span>* (*<span class="keyword">const</span> to_enum)(<span class="keywordtype">size_t</span> x)</div>
<div class="line">) Enum;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">typedef</span> <a class="code" href="typeclass_8h.html#af018200b2431a3ab6c296cc8940ecbe3">typeclass_instance</a>(Enum) Enumerable;</div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#define impl_enum(T, Name, from_enum_f, to_enum_f)                                                                     \</span></div>
<div class="line"><span class="preprocessor">    Enumerable Name(T x)                                                                                               \</span></div>
<div class="line"><span class="preprocessor">    {                                                                                                                  \</span></div>
<div class="line"><span class="preprocessor">        size_t (*const from_enum_)(T e) = (from_enum_f);                                                               \</span></div>
<div class="line"><span class="preprocessor">        T (*const to_enum_)(size_t x)   = (to_enum_f);                                                                 \</span></div>
<div class="line"><span class="preprocessor">        (void)from_enum_;                                                                                              \</span></div>
<div class="line"><span class="preprocessor">        (void)to_enum_;                                                                                                \</span></div>
<div class="line"><span class="preprocessor">        static Enum const tc = {                                                                                       \</span></div>
<div class="line"><span class="preprocessor">            .from_enum = (size_t (*const)(void*))(from_enum_f), .to_enum = (void* (*const)(size_t x))(to_enum_f)       \</span></div>
<div class="line"><span class="preprocessor">        };                                                                                                             \</span></div>
<div class="line"><span class="preprocessor">        return (Enumerable){.tc = &amp;tc, .self = x};                                                                     \</span></div>
<div class="line"><span class="preprocessor">    }</span></div>
</div><!-- fragment --><p class="">Essentially, you can have a struct that stores each of the typeclass pointers you want to combine, and the <code>self</code> member. The <code>impl</code> macro would also be very simple. It should simply define a function that puts the given value into <code>ShowableEnumerable</code>, into <code>self</code>, as well as use the impl functions to get the typeclass instances of that type.</p>
<p class="">With this, if you implemented <code>Show</code> for <code>Antioch*</code> and defined the function as <code>prep_antioch_show</code>, and also implemented <code>Enum</code> with the function name <code>prep_antioch_enum</code>, you could call <code>impl_show_enum</code> using- </p><div class="fragment"><div class="line">impl_enum(Antioch*, prep_antioch_show_enum, prep_antioch_show, prep_antioch_enum)</div>
</div><!-- fragment --><p> The defined function would have the signature- </p><div class="fragment"><div class="line">ShowableEnumerable prep_antioch_show_enum(Antioch* x);</div>
</div><!-- fragment --><p class="">That's it!</p>
<p class="">You can now have functions that require their argument to implement multiple typeclasses- </p><div class="fragment"><div class="line"><span class="keywordtype">void</span> foo(ShowableEnumerable se)</div>
<div class="line">{</div>
<div class="line">    <span class="comment">/* Use the enumerable abilities */</span></div>
<div class="line">    <span class="keywordtype">size_t</span> x = se.enumtc-&gt;from_enum(se.self);</div>
<div class="line">    <span class="comment">/* Use the showable abilities */</span></div>
<div class="line">    <span class="keywordtype">char</span>* s = se.showtc-&gt;show(se.self);</div>
<div class="line">}</div>
</div><!-- fragment --><h1>Putting it all together into a fully generic <code>Iterator</code></h1>
<p class="">Following the typeclass pattern - you can make an <code>Iterator</code> where each element is a typeclass instance. The typeclass instance can either just be for one typeclass (like <code>Show</code>), or it can be for multiple typeclasses (like <code>ShowableEnumerable</code>).</p>
<p class="">Here's a full demonstration all in one snippet, turning an array of <code>Antioch</code>s into an <code>Iterable</code> of <code>Showable</code>s- </p><div class="fragment"><div class="line"><a class="code" href="maybe_8h.html#a0daf26d181160b7fb96d640ed20bb466">DefineMaybe</a>(Showable)</div>
<div class="line"> </div>
<div class="line"><a class="code" href="iterator_8h.html#a938f3e7187cb386e2bf4049753e2ff84">DefineIteratorOf</a>(Showable);</div>
<div class="line"> </div>
<div class="line"><span class="keyword">static</span> <span class="keywordtype">void</span> print(Showable showable)</div>
<div class="line">{</div>
<div class="line">    <span class="keywordtype">char</span>* s = showable.tc-&gt;show(showable.self);</div>
<div class="line">    puts(s);</div>
<div class="line">    free(s);</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keyword">static</span> <span class="keywordtype">void</span> printit(<a class="code" href="iterator_8h.html#a78f1cf949c0e970b2105124f691f5c2a">Iterable</a>(Showable) it)</div>
<div class="line">{</div>
<div class="line">    <span class="keywordflow">foreach</span> (Showable, x, it) {</div>
<div class="line">        print(x);</div>
<div class="line">    }</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span></div>
<div class="line">{</div>
<div class="line">    <span class="keywordtype">size_t</span> i;</div>
<div class="line">    <span class="keywordtype">size_t</span> <span class="keyword">const</span> size;</div>
<div class="line">    Antioch* <span class="keyword">const</span> arr;</div>
<div class="line">} AntiochArrIter;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">static</span> <a class="code" href="maybe_8h.html#af47a0e4269e370939835ecc0cf6c7875">Maybe</a>(Showable) antiochshow_arr_nxt(AntiochArrIter* <span class="keyword">self</span>)</div>
<div class="line">{</div>
<div class="line">    <span class="keywordflow">if</span> (self-&gt;i &gt;= self-&gt;size) {</div>
<div class="line">        <span class="keywordflow">return</span> <a class="code" href="maybe_8h.html#a65cd69857cc806545d68c79464270a97">Nothing</a>(Showable);</div>
<div class="line">    }</div>
<div class="line">    <span class="comment">/*</span></div>
<div class="line"><span class="comment">    Note: This is re-using the address of the element in the array</span></div>
<div class="line"><span class="comment">    This means that the return value goes out of scope once the src array</span></div>
<div class="line"><span class="comment">    goes out of scope (or is freed).</span></div>
<div class="line"><span class="comment">    */</span></div>
<div class="line">    <span class="keywordflow">return</span> <a class="code" href="maybe_8h.html#ae0832f95d5a7ff6845381aa8795fd2a3">Just</a>(prep_antioch_show(self-&gt;arr + self-&gt;i++), Showable);</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keyword">static</span> <a class="code" href="iterator_8h.html#a01e620430099d2eb6192db193e88cff0">impl_iterator</a>(AntiochArrIter*, Showable, prep_antshowarr_itr, antiochshow_arr_nxt)</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">void</span>)</div>
<div class="line">{</div>
<div class="line">    Antioch antarr[] = {grenade, holy, hand};</div>
<div class="line">    <a class="code" href="iterator_8h.html#a78f1cf949c0e970b2105124f691f5c2a">Iterable</a>(Showable) antshowit =</div>
<div class="line">        prep_antshowarr_itr(&amp;(AntiochArrIter){.i = 0, .size = <span class="keyword">sizeof</span>(antarr) / <span class="keyword">sizeof</span>(*antarr), .arr = antarr});</div>
<div class="line">    printit(antshowit);</div>
<div class="line">    <span class="keywordflow">return</span> 0;</div>
<div class="line">}</div>
<div class="ttc" id="aiterator_8h_html_a01e620430099d2eb6192db193e88cff0"><div class="ttname"><a href="iterator_8h.html#a01e620430099d2eb6192db193e88cff0">impl_iterator</a></div><div class="ttdeci">#define impl_iterator(IterType, ElmntType, Name, next_f)</div><div class="ttdoc">Define a function to turn given IterType into an Iterable(ElmntType).</div><div class="ttdef"><b>Definition:</b> iterator.h:123</div></div>
<div class="ttc" id="aiterator_8h_html_a78f1cf949c0e970b2105124f691f5c2a"><div class="ttname"><a href="iterator_8h.html#a78f1cf949c0e970b2105124f691f5c2a">Iterable</a></div><div class="ttdeci">#define Iterable(T)</div><div class="ttdoc">Convenience macro to get the type of the Iterable (typeclass instance) with given element type.</div><div class="ttdef"><b>Definition:</b> iterator.h:48</div></div>
<div class="ttc" id="aiterator_8h_html_a938f3e7187cb386e2bf4049753e2ff84"><div class="ttname"><a href="iterator_8h.html#a938f3e7187cb386e2bf4049753e2ff84">DefineIteratorOf</a></div><div class="ttdeci">#define DefineIteratorOf(T)</div><div class="ttdoc">Define an Iterator typeclass and its Iterable instance for given element type.</div><div class="ttdef"><b>Definition:</b> iterator.h:65</div></div>
<div class="ttc" id="amaybe_8h_html_a0daf26d181160b7fb96d640ed20bb466"><div class="ttname"><a href="maybe_8h.html#a0daf26d181160b7fb96d640ed20bb466">DefineMaybe</a></div><div class="ttdeci">#define DefineMaybe(T)</div><div class="ttdoc">Define a Maybe&lt;T&gt; type.</div><div class="ttdef"><b>Definition:</b> maybe.h:57</div></div>
<div class="ttc" id="amaybe_8h_html_a65cd69857cc806545d68c79464270a97"><div class="ttname"><a href="maybe_8h.html#a65cd69857cc806545d68c79464270a97">Nothing</a></div><div class="ttdeci">#define Nothing(T)</div><div class="ttdoc">Wrap a Nothing value into a Maybe(T).</div><div class="ttdef"><b>Definition:</b> maybe.h:108</div></div>
<div class="ttc" id="amaybe_8h_html_ae0832f95d5a7ff6845381aa8795fd2a3"><div class="ttname"><a href="maybe_8h.html#ae0832f95d5a7ff6845381aa8795fd2a3">Just</a></div><div class="ttdeci">#define Just(v, T)</div><div class="ttdoc">Wrap a Just value into a Maybe(T).</div><div class="ttdef"><b>Definition:</b> maybe.h:91</div></div>
<div class="ttc" id="amaybe_8h_html_af47a0e4269e370939835ecc0cf6c7875"><div class="ttname"><a href="maybe_8h.html#af47a0e4269e370939835ecc0cf6c7875">Maybe</a></div><div class="ttdeci">#define Maybe(T)</div><div class="ttdoc">Convenience macro to get the type of the Maybe defined with a certain type.</div><div class="ttdef"><b>Definition:</b> maybe.h:40</div></div>
</div><!-- fragment --><p> Note: <code>Show</code> and <code>Antioch</code> here have their origins in <a href="#core-parts">Core Parts</a>. You'll remember, the <code>Show</code> impl function for <code>Antioch</code> has the signature- <code>Showable prep_antioch_show(Antioch* x);</code>. The <code>foreach</code> macro is defined in <a href="./examples/iterutils/iterable_utils.h">iterutils</a>. It's using the <code>CONCAT</code> macro, which is defined in <a href="./examples/func_iter.h">func_iter.h</a> </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- start footer part -->

<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.2 </li>
  </ul>
</div>


</body>
</html>
